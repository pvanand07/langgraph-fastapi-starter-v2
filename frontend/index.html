
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Multi Agent</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <style>
:root {
    --primary-color: #304b76;
    --secondary-color: #f0f8ff;
    --text-color: #333;
    --background-color: #f5f7fa;
}
body {
    font-family: 'Poppins', sans-serif;
    line-height: 1.6;
    margin: 0;
    padding: 0;
    background-color: var(--background-color);
    color: var(--text-color);
    font-size: 16px;
}
#app {
    max-width: 100%;
    margin: 0;
    padding: 0;
    height: 100vh;
    overflow: hidden;
}
.chat-wrapper {
    display: flex;
    height: 100vh;
    position: relative;
}
.chat-container {
    background-color: #ffffff;
    border-radius: 15px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    flex: 1;
    height: 100vh;
    transition: all 0.3s ease;
    margin: 10px;
}
.chat-header {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid #e0e0e0;
    background-color: #ffffff;
}
.menu-button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: background-color 0.2s;
}
.menu-button:hover {
    background-color: #f0f0f0;
}
.menu-button svg {
    width: 24px;
    height: 24px;
    stroke: var(--primary-color);
}
.sidebar {
    position: fixed;
    left: 0;
    top: 0;
    width: 280px;
    height: 100vh;
    background-color: #ffffff;
    box-shadow: 2px 0 10px rgba(0,0,0,0.1);
    z-index: 1000;
    transform: translateX(-100%);
    transition: transform 0.3s ease;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
@media (min-width: 901px) {
    .sidebar {
        position: relative;
        transform: translateX(0) !important;
        box-shadow: none;
        border-right: 1px solid #e0e0e0;
    }
    .sidebar-overlay {
        display: none;
    }
    .chat-container {
        margin-left: 0;
    }
    .menu-button {
        display: none;
    }
    .sidebar-close {
        display: none;
    }
}
.sidebar-visible {
    transform: translateX(0);
}
.sidebar-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0,0,0,0.5);
    z-index: 999;
}
.sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid #e0e0e0;
}
.sidebar-header h2 {
    margin: 0;
    font-size: 1.2em;
    color: var(--primary-color);
}
.sidebar-close {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: background-color 0.2s;
}
.sidebar-close:hover {
    background-color: #f0f0f0;
}
.sidebar-close svg {
    width: 20px;
    height: 20px;
    stroke: var(--text-color);
}
.new-chat-button {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin: 15px 20px;
    padding: 12px 16px;
    background-color: var(--primary-color);
    color: #ffffff;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1em;
    font-weight: 500;
    transition: all 0.3s ease;
}
.new-chat-button:hover {
    background-color: #005fa3;
    transform: translateY(-2px);
}
.new-chat-button svg {
    width: 20px;
    height: 20px;
    stroke: #ffffff;
}
.threads-list {
    flex: 1;
    overflow-y: auto;
    padding: 10px 0;
}
.empty-threads {
    padding: 20px;
    text-align: center;
    color: #999;
    font-size: 0.9em;
}
.threads-loading {
    padding: 20px;
    text-align: center;
    color: #999;
}
.thread-item {
    padding: 12px 20px;
    cursor: pointer;
    transition: background-color 0.2s;
    border-left: 3px solid transparent;
}
.thread-item:hover {
    background-color: #f5f5f5;
}
.thread-item.thread-active {
    background-color: var(--secondary-color);
    border-left-color: var(--primary-color);
}
.thread-title {
    font-size: 0.95em;
    color: var(--text-color);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.thread-item.thread-active .thread-title {
    color: var(--primary-color);
    font-weight: 500;
}
.messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px;
    display: flex;
    flex-direction: column;
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
}
.message {
    max-width: 80%;
    margin-bottom: 20px;
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 1em;
    line-height: 1.5;
    word-wrap: break-word;
    animation: fadeIn 0.5s ease;
}
table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
}
table, th, td {
    border: 1px solid #ddd;
}
th, td {
    padding: 10px;
    text-align: left;
}
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
.user-message {
    background-color: var(--primary-color);
    color: #ffffff;
    align-self: flex-end;
    border-bottom-right-radius: 5px;
}
.bot-message {
    background-color: var(--secondary-color);
    color: var(--text-color);
    align-self: flex-start;
    border-bottom-left-radius: 5px;
    position: relative;
}
.copy-button {
    position: absolute;
    top: 5px;
    right: 5px;
    background-color: transparent;
    border: none;
    cursor: pointer;
    padding: 5px;
    transition: all 0.3s ease;
}
.copy-button svg {
    width: 16px;
    height: 16px;
    stroke: var(--primary-color);
}
.copy-button:hover {
    transform: scale(1.1);
}
.input-area {
    display: flex;
    padding: 15px;
    background-color: #ffffff;
    border-top: 1px solid #e0e0e0;
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
}
#user-input {
    flex-grow: 1;
    padding: 12px 15px;
    border: 2px solid var(--primary-color);
    border-radius: 15px;
    font-size: 1em;
    outline: none;
    transition: all 0.3s ease;
}
#user-input:focus {
    box-shadow: 0 0 0 3px rgba(0,119,190,0.3);
}
.upload-button {
    background-color: #ffffff;
    color: var(--primary-color);
    border: 2px solid var(--primary-color);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    margin-right: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}
.upload-button:hover {
    background-color: var(--secondary-color);
    transform: scale(1.05);
}
.upload-button svg {
    width: 24px;
    height: 24px;
}
.send-button, .reset-button {
    background-color: var(--primary-color);
    color: #ffffff;
    border: none;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    margin-left: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}
.send-button:hover, .reset-button:hover {
    background-color: #005fa3;
    transform: scale(1.05);
}
.send-button svg, .reset-button svg {
    width: 24px;
    height: 24px;
}
.upload-status {
    background-color: var(--secondary-color);
    color: var(--text-color);
    align-self: flex-start;
    border-bottom-left-radius: 5px;
    padding: 10px 20px;
    margin-bottom: 10px;
    border-left: 3px solid var(--primary-color);
}
.upload-status.success {
    background-color: #e8f5e9;
    border-left-color: #4caf50;
}
.upload-status.error {
    background-color: #ffebee;
    border-left-color: #f44336;
}
.upload-status.uploading {
    background-color: #fff3e0;
    border-left-color: #ff9800;
}
.option-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 15px;
}
.option-button {
    background-color: #ffffff;
    border: 2px solid var(--primary-color);
    border-radius: 20px;
    padding: 8px 16px;
    font-size: 0.875em;
    cursor: pointer;
    transition: all 0.3s ease;
}
.option-button:hover {
    background-color: var(--secondary-color);
    transform: translateY(-2px);
}
.option-button.selected {
    background-color: var(--primary-color);
    color: #ffffff;
}
.audio-button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0;
    margin-top: 10px;
    transition: all 0.3s ease;
}
.audio-button:hover {
    transform: scale(1.1);
}
.audio-button svg {
    width: 30px;
    height: 30px;
    fill: var(--primary-color);
}
.dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: #5853c0;
    margin: 0 3px;
    animation: bounce 1.4s infinite ease-in-out;
}
.dot:nth-child(1) { animation-delay: -0.32s; }
.dot:nth-child(2) { animation-delay: -0.16s; }
@keyframes bounce {
    0%, 80%, 100% { 
        transform: scale(0);
    } 40% { 
        transform: scale(1.0);
    }
}
.chat-container {
    position: relative;
}
.input-area {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 10;
    transition: transform 0.3s ease;
}
.messages {
    padding-bottom: 80px;
}
.input-hidden {
    transform: translateY(100%);
}
.tool-options {
    position: absolute;
    bottom: 100%;
    left: 0;
    background-color: #ffffff;
    border: 1px solid #ddd;  
    border-radius: 8px;      
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);  
    display: flex;
    flex-direction: column;
    width: auto;
    min-width: 120px;        
    margin-bottom: 10px;
}
.tool-options button {
    padding: 10px 15px;      
    border: none;
    background: none;
    text-align: left;
    cursor: pointer;
    white-space: nowrap;
    transition: background-color 0.3s ease;  
    font-size: 1em;          
    font-weight: 500;         
    color: #333;
    border-radius: 4px;
}
.tool-options button:hover {
    background-color: #e0e0e0;  
    color: #000;              
}
details {
    margin-top: 10px;
    border-radius: 4px;
    padding: 5px;
}
summary {
    cursor: pointer;
    font-weight: bold;
}
.ref-content {
    margin-top: 10px;
    justify-content: center;
}
.ref-item {
    margin-bottom: 0px;
}
.ref-item small {
    color: #666;
}
hr {
    margin: 10px 0;
    border: none;
    border-top: 1px solid #eee;
}
.ref-link {
    text-decoration: none;
    color: inherit;
    display: block;
    padding: 5px;
    border-radius: 4px;
    transition: background-color 0.2s;
}
.ref-link:hover {
    background-color: #e3e3ea;
    color: inherit;
}
.ref-link:visited {
    color: inherit;
}
img, video {
    max-width: 100%;
    height: auto;
}
.download-buttons {
    display: flex;
    gap: 5px;
    margin-top: 5px;
}
.download-button {
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    border-radius: 3px;
    padding: 2px 5px;
    font-size: 0.8em;
    cursor: pointer;
    transition: background-color 0.3s;
}
.download-button:hover {
    background-color: #e0e0e0;
}
@media (max-width: 600px) {
    body {
        font-size: 14px;
    }
    #app {
        padding: 0;
    }
    .chat-wrapper {
        height: 100vh;
    }
    .chat-container {
        height: 100vh;
        border-radius: 0;
        margin: 0;
    }
    .sidebar {
        width: 100%;
    }
    .messages {
        padding: 10px;
    }
    .message {
        max-width: 90%;
    }
    #user-input {
        font-size: 16px;
        padding: 12px;
    }
    .upload-button, .send-button, .reset-button {
        width: 44px;
        height: 44px;
    }
    .tool-options {
        width: 100%;
        left: 0;
        right: 0;
    }
    .tool-options button {
        padding: 12px 15px;
    }
}
@media (max-width: 900px) and (orientation: landscape) {
    .chat-container {
        height: 100vh;
    }
    .messages {
        max-height: calc(100vh - 60px);
    }
}
@media (hover: none) {
    .option-button:active {
        background-color: var(--primary-color);
        color: #ffffff;
    }
}
/* Email Modal Styles */
.email-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.3s ease;
}
.email-modal {
    background-color: #ffffff;
    border-radius: 15px;
    padding: 30px;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    animation: slideUp 0.3s ease;
}
@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
.email-modal h2 {
    margin: 0 0 15px 0;
    color: var(--primary-color);
    font-size: 1.5em;
}
.email-modal p {
    margin: 0 0 20px 0;
    color: #666;
    font-size: 0.95em;
}
.email-modal input {
    width: 100%;
    padding: 12px 15px;
    border: 2px solid var(--primary-color);
    border-radius: 8px;
    font-size: 1em;
    outline: none;
    transition: all 0.3s ease;
    box-sizing: border-box;
    margin-bottom: 15px;
}
.email-modal input:focus {
    box-shadow: 0 0 0 3px rgba(48, 75, 118, 0.2);
}
.email-modal-buttons {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
}
.email-modal-button {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    font-size: 1em;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
}
.email-modal-button.primary {
    background-color: var(--primary-color);
    color: #ffffff;
}
.email-modal-button.primary:hover {
    background-color: #005fa3;
    transform: translateY(-2px);
}
.email-modal-button.secondary {
    background-color: #f0f0f0;
    color: var(--text-color);
}
.email-modal-button.secondary:hover {
    background-color: #e0e0e0;
}
.email-error {
    color: #d32f2f;
    font-size: 0.875em;
    margin-top: -10px;
    margin-bottom: 10px;
}
.user-email-display {
    padding: 8px 15px;
    font-size: 0.875em;
    color: #666;
    border-bottom: 1px solid #e0e0e0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.user-email-display span {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
}
.user-email-display button {
    background: none;
    border: none;
    color: var(--primary-color);
    cursor: pointer;
    padding: 4px 8px;
    font-size: 0.875em;
    text-decoration: underline;
    margin-left: 10px;
}
.user-email-display button:hover {
    color: #005fa3;
}
    </style>
</head>
<body>
    <div id="app">
        <!-- Email Modal -->
        <div class="email-modal-overlay" v-if="showEmailModal" @click.self="closeEmailModal">
            <div class="email-modal">
                <h2>Enter Your Email</h2>
                <p>Please enter your email address to continue using the chat.</p>
                <input 
                    type="email" 
                    v-model="emailInput" 
                    @keyup.enter="submitEmail"
                    placeholder="your.email@example.com"
                    ref="emailInput"
                >
                <div v-if="emailError" class="email-error">{{ emailError }}</div>
                <div class="email-modal-buttons">
                    <button class="email-modal-button secondary" @click="closeEmailModal">Cancel</button>
                    <button class="email-modal-button primary" @click="submitEmail">Continue</button>
                </div>
            </div>
        </div>
        <!-- Chat Container -->
        <div class="chat-wrapper">
            <!-- Sidebar -->
            <div class="sidebar" :class="{ 'sidebar-visible': sidebarVisible }">
                <div class="sidebar-header">
                    <h2>FMCG Agent</h2>
                    <button class="sidebar-close" @click="toggleSidebar">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div class="user-email-display" v-if="userId && userId !== 'string'">
                    <span>{{ userId }}</span>
                    <button @click="changeEmail">Change</button>
                </div>
                <button class="new-chat-button" @click="startNewChat">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                    New Chat
                </button>
                <div class="threads-list" v-if="!loadingThreads">
                    <div v-if="threads.length === 0" class="empty-threads">
                        No conversations yet
                    </div>
                    <div v-else>
                        <div v-for="thread in threads" 
                             :key="thread.id" 
                             class="thread-item"
                             :class="{ 'thread-active': thread.id === activeThreadId }"
                             @click="switchToThread(thread.id)">
                            <div class="thread-title">{{ thread.title || 'Untitled' }}</div>
                        </div>
                    </div>
                </div>
                <div v-else class="threads-loading">
                    Loading...
                </div>
            </div>
            <!-- Sidebar Overlay (mobile) -->
            <div class="sidebar-overlay" 
                 v-if="sidebarVisible" 
                 @click="toggleSidebar"></div>
            <!-- Main Chat Container -->
            <div class="chat-container">
                <div class="chat-header">
                    <button class="menu-button" @click="toggleSidebar">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="3" y1="12" x2="21" y2="12"></line>
                            <line x1="3" y1="6" x2="21" y2="6"></line>
                            <line x1="3" y1="18" x2="21" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div class="messages" ref="messageContainer" @scroll="handleScroll">
                <div v-for="(message, index) in messages" :key="index" 
                     :class="[
                         message.type === 'upload' ? 'upload-status' : 'message',
                         message.type === 'user' ? 'user-message' : message.type === 'bot' ? 'bot-message' : '',
                         message.status ? message.status : ''
                     ]">
                    <div v-if="message.type === 'bot' && message.content === ''" id="typing-animation"></div>
                    <div v-else v-html="message.content"></div>
                    <button v-if="message.type === 'bot' && message.audio" @click="toggleAudio(index)" class="audio-button">
                        <svg v-if="!message.isPlaying" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        <svg v-else xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                    </button>
                    <button v-if="message.type === 'bot' && message.rawResponse" @click="copyMarkdownToClipboard(message.rawResponse)" class="copy-button">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                            <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="input-area">
                <input type="file" id="file-input" ref="fileInput" @change="handleFileSelect" accept=".pdf,.docx,.xlsx,.xls" multiple style="display: none;">
                <button class="upload-button" @click="triggerFileInput" title="Upload files (PDF, DOCX, Excel) - Multiple files supported">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </button>
                <input type="text" id="user-input" v-model="userInput" @keyup.enter="sendMessage" placeholder="Type your message...">
                <button class="send-button" @click="sendMessage">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                </button>
                <button class="reset-button" @click="resetConversation">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                        <path d="M3 3v5h5"></path>
                    </svg>
                </button>
            </div>
        </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        marked.setOptions({
            highlight: function (code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    return hljs.highlight(code, { language: lang }).value;
                } else {
                    return hljs.highlightAuto(code).value;
                }
            },
            sanitize: false
        });
        
        function createTypingAnimation() {
          const container = document.getElementById('typing-animation');
          for (let i = 0; i < 3; i++) {
            const dot = document.createElement('div');
            dot.className = 'dot';
            container.appendChild(dot);
          }
        }

        // Cookie utility functions
        function setCookie(name, value, days = 365) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            const expires = "expires=" + date.toUTCString();
            document.cookie = name + "=" + value + ";" + expires + ";path=/";
        }
        
        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }
        
        function deleteCookie(name) {
            document.cookie = name + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
        }

        function extractCustomFileName(html) {
              // Try to find the first h1-h4 tag content
              const headingMatch = html.match(/<h[1-4][^>]*>(.*?)<\/h[1-4]>/i);
              if (headingMatch) {
                  return headingMatch[1].trim();
              }
          
              // If no heading found, use the first 7 words
              const textContent = html.replace(/<[^>]+>/g, ' ').trim();
              const words = textContent.split(/\s+/);
              return words.slice(0, 7).join(' ');
          } 
      
        async function convertHtmlToFile(html, fileType, customFileName = '') {
          
          const url = 'https://pvanand-web-scraping.hf.space/html_to_' + fileType;
          customFileName = extractCustomFileName(html);
          
          function sanitizeFileName(name) {
            return (name.replace(/[^a-z0-9\s]/gi, '')
                       .toLowerCase()
                       .replace(/\s+/g, '_')
                       .substring(0, 50)) || 'generated_report';
          }
          const fileName = `${sanitizeFileName(customFileName || 'generated_report')}.${fileType}`;
          try {
            const response = await fetch(url, {
              method: 'POST',
              headers: { 
                'accept': 'application/json',
                'Content-Type': 'application/json' 
              },
              body: JSON.stringify({ html_content: html })
            });
            if (!response.ok) throw new Error('Conversion failed');
            const blob = await response.blob();
            const a = document.createElement('a');
            a.href = window.URL.createObjectURL(blob);
            a.download = fileName;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(a.href);
          } catch (error) {
            throw new Error(`Failed to download ${fileName}. Please try again.`);
          }
        }

        const app = new Vue({
            el: '#app',
            data: {
                messages: [],
                userInput: '',
                selectedOptions: {},
                conversationId: '',
                threadId: null,
                currentAudio: null,
                isScrollingUp: false,
                lastScrollTop: 0,
                chatStarted: true,
                threads: [],
                loadingThreads: false,
                sidebarVisible: window.innerWidth > 900,
                activeThreadId: null,
                userId: null,
                showEmailModal: false,
                emailInput: '',
                emailError: '',
                uploadingFile: false,
            },
            methods: {
                // File upload methods
                triggerFileInput() {
                    if (!this.userId || this.userId === 'string') {
                        this.showEmailModal = true;
                        this.$nextTick(() => {
                            if (this.$refs.emailInput) {
                                this.$refs.emailInput.focus();
                            }
                        });
                        return;
                    }
                    this.$refs.fileInput.click();
                },
                async handleFileSelect(event) {
                    const files = Array.from(event.target.files || []);
                    if (files.length === 0) return;
                    
                    // Reset file input
                    event.target.value = '';
                    
                    // Check if userId is set
                    if (!this.userId || this.userId === 'string') {
                        this.showEmailModal = true;
                        return;
                    }
                    
                    // Check if any Excel files require session_id
                    const hasExcel = files.some(file => 
                        file.name.toLowerCase().endsWith('.xlsx') || 
                        file.name.toLowerCase().endsWith('.xls')
                    );
                    
                    // Initialize thread_id if needed for Excel files
                    if (hasExcel && !this.threadId) {
                        this.threadId = uuid.v4();
                        this.activeThreadId = this.threadId;
                    }
                    
                    // Show uploading status for all files
                    const uploadIndices = [];
                    files.forEach(file => {
                        const uploadIndex = this.messages.push({
                            type: 'upload',
                            content: `Uploading ${file.name}...`,
                            status: 'uploading'
                        }) - 1;
                        uploadIndices.push({ index: uploadIndex, filename: file.name });
                    });
                    
                    this.uploadingFile = true;
                    
                    try {
                        // Create FormData with all files
                        const formData = new FormData();
                        files.forEach(file => {
                            formData.append('files', file);
                        });
                        formData.append('user_id', this.userId);
                        
                        // Add session_id if we have Excel files
                        if (hasExcel && this.threadId) {
                            formData.append('session_id', this.threadId);
                        }
                        
                        // Upload files
                        const response = await fetch('/api/v1/upload', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ detail: 'Upload failed' }));
                            throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                        }
                        
                        const result = await response.json();
                        
                        // Update status messages for each file
                        const resultMap = new Map();
                        result.results.forEach((fileResult, idx) => {
                            resultMap.set(fileResult.filename, fileResult);
                        });
                        
                        // Update success messages
                        uploadIndices.forEach(({ index, filename }) => {
                            const fileResult = resultMap.get(filename);
                            if (fileResult) {
                                let successMessage = '';
                                if (fileResult.file_type === 'document') {
                                    successMessage = `âœ… **${fileResult.filename}** uploaded successfully!\n- Pages: ${fileResult.page_count}\n- Document ID: ${fileResult.doc_id}`;
                                } else if (fileResult.file_type === 'excel') {
                                    successMessage = `âœ… **${fileResult.filename}** uploaded successfully!\n- Table: ${fileResult.table_name}\n- Rows: ${fileResult.row_count}\n- Columns: ${fileResult.column_count}`;
                                } else {
                                    successMessage = `âœ… **${fileResult.filename}** uploaded successfully!`;
                                }
                                this.$set(this.messages[index], 'content', marked.parse(successMessage));
                                this.$set(this.messages[index], 'status', 'success');
                            }
                        });
                        
                        // Show error messages for failed files
                        if (result.errors && result.errors.length > 0) {
                            result.errors.forEach((error, idx) => {
                                // Find the corresponding upload index
                                const uploadItem = uploadIndices.find(item => item.filename === error.filename);
                                if (uploadItem) {
                                    const errorMessage = `âŒ Failed to upload **${error.filename}**: ${error.error}`;
                                    this.$set(this.messages[uploadItem.index], 'content', marked.parse(errorMessage));
                                    this.$set(this.messages[uploadItem.index], 'status', 'error');
                                }
                            });
                        }
                        
                        // Show summary if multiple files
                        if (files.length > 1) {
                            const summaryIndex = this.messages.push({
                                type: 'upload',
                                content: `ðŸ“Š **Upload Summary**: ${result.successful} successful, ${result.failed} failed out of ${result.total_files} files`,
                                status: result.failed === 0 ? 'success' : 'error'
                            }) - 1;
                        }
                        
                        // Refresh threads list if this is a new thread
                        if (hasExcel && !this.activeThreadId) {
                            await this.loadThreads();
                        }
                        
                    } catch (error) {
                        console.error('Upload error:', error);
                        // Mark all as failed
                        uploadIndices.forEach(({ index, filename }) => {
                            const errorMessage = `âŒ Failed to upload **${filename}**: ${error.message}`;
                            this.$set(this.messages[index], 'content', marked.parse(errorMessage));
                            this.$set(this.messages[index], 'status', 'error');
                        });
                    } finally {
                        this.uploadingFile = false;
                        this.$nextTick(() => this.scrollToBottom());
                    }
                },
                // Email modal methods
                submitEmail() {
                    this.emailError = '';
                    const email = this.emailInput.trim();
                    
                    // Basic email validation
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    if (!email) {
                        this.emailError = 'Please enter your email address';
                        return;
                    }
                    if (!emailRegex.test(email)) {
                        this.emailError = 'Please enter a valid email address';
                        return;
                    }
                    
                    // Store email in cookie and set as userId
                    setCookie('user_email', email);
                    this.userId = email;
                    this.showEmailModal = false;
                    this.emailInput = '';
                    this.emailError = '';
                    
                    // Load threads after setting userId
                    this.loadThreads();
                },
                closeEmailModal() {
                    // Don't allow closing if no email is set
                    if (!this.userId || this.userId === 'string') {
                        return;
                    }
                    this.showEmailModal = false;
                    this.emailInput = '';
                    this.emailError = '';
                },
                changeEmail() {
                    this.showEmailModal = true;
                    this.emailInput = this.userId || '';
                    this.$nextTick(() => {
                        if (this.$refs.emailInput) {
                            this.$refs.emailInput.focus();
                        }
                    });
                },
                async loadThreads() {
                    if (!this.userId || this.userId === 'string') {
                        return;
                    }
                    this.loadingThreads = true;
                    try {
                        const response = await fetch(`/api/v1/threads?user_id=${encodeURIComponent(this.userId)}&limit=20&order=desc`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        this.threads = data.threads || [];
                    } catch (error) {
                        console.error('Error loading threads:', error);
                        this.threads = [];
                    } finally {
                        this.loadingThreads = false;
                    }
                },
                async loadThreadMessages(threadId) {
                    if (!this.userId || this.userId === 'string') {
                        throw new Error('User ID not set');
                    }
                    try {
                        const response = await fetch(`/api/v1/threads/${threadId}/messages?user_id=${encodeURIComponent(this.userId)}&limit=50&order=asc`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        return data.messages || [];
                    } catch (error) {
                        console.error('Error loading messages:', error);
                        throw error;
                    }
                },
                async switchToThread(threadId) {
                    if (this.threadId === threadId) {
                        // Already viewing this thread, just close sidebar on mobile
                        if (window.innerWidth <= 900) {
                            this.sidebarVisible = false;
                        }
                        return;
                    }
                    
                    try {
                        // Load messages for the thread
                        const messages = await this.loadThreadMessages(threadId);
                        
                        // Clear current messages
                        this.messages = [];
                        
                        // Convert API messages to Vue message format
                        messages.forEach(msg => {
                            const messageType = msg.role === 'user' ? 'user' : 'bot';
                            this.messages.push({
                                type: messageType,
                                content: messageType === 'user' 
                                    ? marked.parse(msg.content) 
                                    : marked.parse(msg.content),
                                rawResponse: messageType === 'bot' ? msg.content : null,
                                audio: null,
                                isPlaying: false
                            });
                        });
                        
                        // Set active thread
                        this.threadId = threadId;
                        this.activeThreadId = threadId;
                        this.chatStarted = true;
                        
                        // Close sidebar on mobile
                        if (window.innerWidth <= 900) {
                            this.sidebarVisible = false;
                        }
                        
                        // Scroll to bottom
                        this.$nextTick(() => {
                            this.scrollToBottom();
                        });
                        
                        // Refresh threads list to update ordering
                        await this.loadThreads();
                    } catch (error) {
                        console.error('Error switching thread:', error);
                        alert('Failed to load conversation. Please try again.');
                    }
                },
                startNewChat() {
                    this.threadId = null;
                    this.activeThreadId = null;
                    this.messages = [];
                    this.selectedOptions = {};
                    this.userInput = '';
                    this.isScrollingUp = false;
                    this.lastScrollTop = 0;
                    
                    // Close sidebar on mobile
                    if (window.innerWidth <= 900) {
                        this.sidebarVisible = false;
                    }
                    
                    // Refresh threads list
                    this.loadThreads();
                },
                toggleSidebar() {
                    this.sidebarVisible = !this.sidebarVisible;
                },
                async sendMessage() {
                    if (!this.userInput.trim()) return;
                    
                    // Check if userId is set
                    if (!this.userId || this.userId === 'string') {
                        this.showEmailModal = true;
                        this.$nextTick(() => {
                            if (this.$refs.emailInput) {
                                this.$refs.emailInput.focus();
                            }
                        });
                        return;
                    }
                    
                    this.messages.push({ type: 'user', content: marked.parse(this.userInput) });
                    const message = this.userInput;
                    this.userInput = '';
                    this.selectedOptions = {};
                    let streamingIndex = this.messages.push({ type: 'bot', content: '' }) - 1;
                    
                    this.$nextTick(() => {
                        createTypingAnimation();
                    });
                    try {
                        // Initialize thread_id if not set (generate new UUID for new conversation)
                        if (!this.threadId) {
                            this.threadId = uuid.v4();
                            this.activeThreadId = this.threadId;
                        }
                        
                        const response = await fetch('/api/v1/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                query: message,
                                thread_id: this.threadId,
                                user_id: this.userId,
                                model_id: 'openai/gpt-4o-mini'
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let rawResponse = '';
                        let toolEvents = [];
                        let buffer = '';
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop() || ''; // Keep incomplete line in buffer
                            
                            for (const line of lines) {
                                if (!line.trim()) continue;
                                
                                // Handle SSE format (strip "data: " prefix if present)
                                let jsonLine = line.trim();
                                if (jsonLine.startsWith('data: ')) {
                                    jsonLine = jsonLine.substring(6);
                                }
                                
                                try {
                                    const chunk = JSON.parse(jsonLine);
                                    
                                    if (chunk.type === 'chunk' && chunk.content) {
                                        rawResponse += chunk.content;
                                        this.$set(this.messages[streamingIndex], 'content', marked.parse(rawResponse));
                                    }
                                    else if (chunk.type === 'tool_start') {
                                        toolEvents.push({
                                            type: 'tool_start',
                                            name: chunk.name,
                                            input: chunk.input
                                        });
                                    }
                                    else if (chunk.type === 'tool_end') {
                                        toolEvents.push({
                                            type: 'tool_end',
                                            name: chunk.name,
                                            output: chunk.output
                                        });
                                    }
                                    else if (chunk.type === 'full_response' && chunk.content) {
                                        rawResponse = chunk.content;
                                        this.$set(this.messages[streamingIndex], 'content', marked.parse(rawResponse));
                                        this.$set(this.messages[streamingIndex], 'rawResponse', rawResponse);
                                        
                                        // Display tool events if any
                                        if (toolEvents.length > 0) {
                                            let toolsMessage = "\n\n**Tools Used:**\n";
                                            toolEvents.forEach(event => {
                                                if (event.type === 'tool_start') {
                                                    const inputStr = typeof event.input === 'object' 
                                                        ? JSON.stringify(event.input) 
                                                        : event.input;
                                                    toolsMessage += `- ${event.name.charAt(0).toUpperCase() + event.name.slice(1)}: ${inputStr}\n`;
                                                }
                                            });
                                            this.$set(this.messages[streamingIndex], 'content', 
                                                this.messages[streamingIndex].content + marked.parse(toolsMessage));
                                        }
                                    }
                                    else if (chunk.type === 'error') {
                                        throw new Error(chunk.content || 'An error occurred');
                                    }
                                } catch (parseError) {
                                    // Skip invalid JSON lines
                                    console.warn('Failed to parse chunk:', line, parseError);
                                }
                            }
                        }
                        
                        // Process any remaining buffer
                        if (buffer.trim()) {
                            try {
                                const chunk = JSON.parse(buffer);
                                if (chunk.type === 'full_response' && chunk.content) {
                                    rawResponse = chunk.content;
                                    this.$set(this.messages[streamingIndex], 'content', marked.parse(rawResponse));
                                    this.$set(this.messages[streamingIndex], 'rawResponse', rawResponse);
                                }
                            } catch (e) {
                                // Ignore parse errors for buffer
                            }
                        }
                        
                        // Ensure rawResponse is set
                        if (!this.messages[streamingIndex].rawResponse) {
                            this.$set(this.messages[streamingIndex], 'rawResponse', rawResponse);
                        }
                        
                        // Generate audio from cleaned text
                        const cleanText = rawResponse.replace(/[#!*_\[\]\(\)`]/g, '');
                        const audioUrl = await this.convertToSpeech(cleanText);
                        if (audioUrl) {
                            this.$set(this.messages[streamingIndex], 'audio', audioUrl);
                        }
                        
                        // Refresh threads list after message is sent
                        await this.loadThreads();
                    } catch (error) {
                        console.error('Error:', error);
                        this.messages.push({ type: 'bot', content: 'An error occurred while processing your request: ' + error.message });
                    }
                    this.$nextTick(() => this.scrollToBottom());
                },
                handleScroll(event) {
                    const st = event.target.scrollTop;
                    this.isScrollingUp = st < this.lastScrollTop;
                    this.lastScrollTop = st <= 0 ? 0 : st;
                },
                renderClarificationQuestions(clarification, messageIndex) {
                    if (!clarification || clarification.length === 0) return;
    
                    let clarificationHtml = '';
                    clarification.forEach((item, questionIndex) => {
                        clarificationHtml += `<strong>${item.question}</strong><br>`;
                        clarificationHtml += '<div class="option-buttons">';
                        item.options.forEach((option, optionIndex) => {
                            const escapedOption = option.replace(/'/g, "\\'");
                            clarificationHtml += `<button class="option-button" onclick="app.toggleOption('${escapedOption}', ${questionIndex}, ${optionIndex})">${option}</button>`;
                        });
                        clarificationHtml += '</div><br>';
                    });
    
                    this.$set(this.messages[messageIndex], 'content', this.messages[messageIndex].content + marked.parse(clarificationHtml));
                    this.$nextTick(() => {
                        this.scrollToBottom();
                        this.updateButtonStates();
                    });
                },
                toggleOption(option, questionIndex, optionIndex) {
                    if (!this.selectedOptions[questionIndex]) {
                        this.$set(this.selectedOptions, questionIndex, []);
                    }
        
                    const index = this.selectedOptions[questionIndex].indexOf(option);
                    if (index > -1) {
                        this.selectedOptions[questionIndex].splice(index, 1);
                    } else {
                        this.selectedOptions[questionIndex].push(option);
                    }
        
                    this.updateInputFromSelectedOptions();
                    this.updateButtonStates();
                },
                updateInputFromSelectedOptions() {
                    this.userInput = Object.entries(this.selectedOptions)
                        .map(([questionIndex, options]) => 
                            `Q${parseInt(questionIndex) + 1}: ${options.join(', ')}`)
                        .join(' | ');
                    this.$nextTick(() => document.getElementById('user-input').focus());
                },
                updateButtonStates() {
                    Object.entries(this.selectedOptions).forEach(([questionIndex, options]) => {
                        const buttons = document.querySelectorAll(`.option-buttons:nth-of-type(${parseInt(questionIndex) + 1}) .option-button`);
                        buttons.forEach((button) => {
                            if (options.includes(button.textContent)) {
                                button.classList.add('selected');
                            } else {
                                button.classList.remove('selected');
                            }
                        });
                    });
                },
                resetConversation() {
                    this.startNewChat();
                },
                scrollToBottom() {
                    const container = this.$refs.messageContainer;
                    container.scrollTop = container.scrollHeight;
                },
                async convertToSpeech(text) {
                    const voice = 'en-US-JennyNeural';
                    const encodedText = encodeURIComponent(text);
                    try {
                        const response = await fetch(`https://pvanand-audio-chat-indic.hf.space/auto-tts?text=${encodedText}`, {
                            method: 'GET',
                            headers: {
                                'accept': 'application/json'
                            }
                        });
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const blob = await response.blob();
                        return URL.createObjectURL(blob);
                    } catch (error) {
                        console.error('Error:', error);
                        return null;
                    }
                },
                toggleAudio(index) {
                    const message = this.messages[index];
                    if (this.currentAudio && this.currentAudio !== message.audioElement) {
                        this.currentAudio.pause();
                        this.messages.forEach(m => {
                            if (m.audioElement === this.currentAudio) {
                                m.isPlaying = false;
                            }
                        });
                    }
                    if (!message.audioElement) {
                        message.audioElement = new Audio(message.audio);
                        message.audioElement.addEventListener('ended', () => {
                            message.isPlaying = false;
                            this.$forceUpdate();
                        });
                    }
                    if (message.isPlaying) {
                        message.audioElement.pause();
                    } else {
                        message.audioElement.play();
                        this.currentAudio = message.audioElement;
                    }
                    message.isPlaying = !message.isPlaying;
                    this.$forceUpdate();
                },
                copyMarkdownToClipboard(rawResponse) {
                    navigator.clipboard.writeText(rawResponse).then(() => {
                        // remove alert
                    }).catch(err => {
                        console.error('Failed to copy: ', err);
                    });
                },
                async downloadResponse(rawResponse, fileType) {
                    try {
                        const html = marked.parse(rawResponse);
                        await convertHtmlToFile(html, fileType);
                    } catch (error) {
                        console.error('Error downloading file:', error);
                        // You might want to show an error message to the user here
                    }
                },
            },
            watch: {
                userInput(newVal, oldVal) {
                    // Watch for user input changes if needed
                }
            },
            mounted() {
                // Check for email in cookies
                const savedEmail = getCookie('user_email');
                if (savedEmail) {
                    this.userId = savedEmail;
                    this.resetConversation();
                    // Load threads on mount
                    this.loadThreads();
                } else {
                    // Show email modal if no email is found
                    this.showEmailModal = true;
                    this.$nextTick(() => {
                        if (this.$refs.emailInput) {
                            this.$refs.emailInput.focus();
                        }
                    });
                }
            }
        });
    </script>
</body>
</html>
