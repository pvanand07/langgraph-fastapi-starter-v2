
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Multi Agent</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <style>
:root {
    --primary-color: #304b76;
    --secondary-color: #f0f8ff;
    --text-color: #333;
    --background-color: #f5f7fa;
}
body {
    font-family: 'Poppins', sans-serif;
    line-height: 1.6;
    margin: 0;
    padding: 0;
    background-color: var(--background-color);
    color: var(--text-color);
    font-size: 16px;
}
#app {
    max-width: 100%;
    margin: 0;
    padding: 0;
    height: 100vh;
    overflow: hidden;
}
.chat-wrapper {
    display: flex;
    height: 100vh;
    position: relative;
}
.chat-container {
    background-color: #ffffff;
    border-radius: 15px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    flex: 1;
    height: 100vh;
    transition: all 0.3s ease;
    margin: 10px;
}
.chat-header {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid #e0e0e0;
    background-color: #ffffff;
}
.menu-button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: background-color 0.2s;
}
.menu-button:hover {
    background-color: #f0f0f0;
}
.menu-button svg {
    width: 24px;
    height: 24px;
    stroke: var(--primary-color);
}
.sidebar {
    position: fixed;
    left: 0;
    top: 0;
    width: 280px;
    height: 100vh;
    background-color: #ffffff;
    box-shadow: 2px 0 10px rgba(0,0,0,0.1);
    z-index: 1000;
    transform: translateX(-100%);
    transition: transform 0.3s ease;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
@media (min-width: 901px) {
    .sidebar {
        position: relative;
        transform: translateX(0) !important;
        box-shadow: none;
        border-right: 1px solid #e0e0e0;
    }
    .sidebar-overlay {
        display: none;
    }
    .chat-container {
        margin-left: 0;
    }
    .menu-button {
        display: none;
    }
    .sidebar-close {
        display: none;
    }
}
.sidebar-visible {
    transform: translateX(0);
}
.sidebar-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0,0,0,0.5);
    z-index: 999;
}
.sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid #e0e0e0;
}
.sidebar-header h2 {
    margin: 0;
    font-size: 1.2em;
    color: var(--primary-color);
}
.sidebar-close {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: background-color 0.2s;
}
.sidebar-close:hover {
    background-color: #f0f0f0;
}
.sidebar-close svg {
    width: 20px;
    height: 20px;
    stroke: var(--text-color);
}
.new-chat-button {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin: 15px 20px;
    padding: 12px 16px;
    background-color: var(--primary-color);
    color: #ffffff;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1em;
    font-weight: 500;
    transition: all 0.3s ease;
}
.new-chat-button:hover {
    background-color: #005fa3;
    transform: translateY(-2px);
}
.new-chat-button svg {
    width: 20px;
    height: 20px;
    stroke: #ffffff;
}
.threads-list {
    flex: 1;
    overflow-y: auto;
    padding: 10px 0;
}
.empty-threads {
    padding: 20px;
    text-align: center;
    color: #999;
    font-size: 0.9em;
}
.threads-loading {
    padding: 20px;
    text-align: center;
    color: #999;
}
.thread-item {
    padding: 12px 20px;
    cursor: pointer;
    transition: background-color 0.2s;
    border-left: 3px solid transparent;
}
.thread-item:hover {
    background-color: #f5f5f5;
}
.thread-item.thread-active {
    background-color: var(--secondary-color);
    border-left-color: var(--primary-color);
}
.thread-title {
    font-size: 0.95em;
    color: var(--text-color);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.thread-item.thread-active .thread-title {
    color: var(--primary-color);
    font-weight: 500;
}
.messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px;
    display: flex;
    flex-direction: column;
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
}
.message {
    max-width: 80%;
    margin-bottom: 20px;
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 1em;
    line-height: 1.5;
    word-wrap: break-word;
    animation: fadeIn 0.5s ease;
}
table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
}
table, th, td {
    border: 1px solid #ddd;
}
th, td {
    padding: 10px;
    text-align: left;
}
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
.user-message {
    background-color: var(--primary-color);
    color: #ffffff;
    align-self: flex-end;
    border-bottom-right-radius: 5px;
}
.bot-message {
    background-color: var(--secondary-color);
    color: var(--text-color);
    align-self: flex-start;
    border-bottom-left-radius: 5px;
    position: relative;
}
.copy-button {
    position: absolute;
    top: 5px;
    right: 5px;
    background-color: transparent;
    border: none;
    cursor: pointer;
    padding: 5px;
    transition: all 0.3s ease;
}
.copy-button svg {
    width: 16px;
    height: 16px;
    stroke: var(--primary-color);
}
.copy-button:hover {
    transform: scale(1.1);
}
.input-area {
    display: flex;
    padding: 15px;
    background-color: #ffffff;
    border-top: 1px solid #e0e0e0;
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
}
#user-input {
    flex-grow: 1;
    padding: 12px 15px;
    border: 2px solid var(--primary-color);
    border-radius: 15px;
    font-size: 1em;
    outline: none;
    transition: all 0.3s ease;
}
#user-input:focus {
    box-shadow: 0 0 0 3px rgba(0,119,190,0.3);
}
.send-button, .reset-button {
    background-color: var(--primary-color);
    color: #ffffff;
    border: none;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    margin-left: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}
.send-button:hover, .reset-button:hover {
    background-color: #005fa3;
    transform: scale(1.05);
}
.send-button svg, .reset-button svg {
    width: 24px;
    height: 24px;
}
.option-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 15px;
}
.option-button {
    background-color: #ffffff;
    border: 2px solid var(--primary-color);
    border-radius: 20px;
    padding: 8px 16px;
    font-size: 0.875em;
    cursor: pointer;
    transition: all 0.3s ease;
}
.option-button:hover {
    background-color: var(--secondary-color);
    transform: translateY(-2px);
}
.option-button.selected {
    background-color: var(--primary-color);
    color: #ffffff;
}
.audio-button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0;
    margin-top: 10px;
    transition: all 0.3s ease;
}
.audio-button:hover {
    transform: scale(1.1);
}
.audio-button svg {
    width: 30px;
    height: 30px;
    fill: var(--primary-color);
}
.dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: #5853c0;
    margin: 0 3px;
    animation: bounce 1.4s infinite ease-in-out;
}
.dot:nth-child(1) { animation-delay: -0.32s; }
.dot:nth-child(2) { animation-delay: -0.16s; }
@keyframes bounce {
    0%, 80%, 100% { 
        transform: scale(0);
    } 40% { 
        transform: scale(1.0);
    }
}
.chat-container {
    position: relative;
}
.input-area {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 10;
    transition: transform 0.3s ease;
}
.messages {
    padding-bottom: 80px;
}
.input-hidden {
    transform: translateY(100%);
}
.tool-options {
    position: absolute;
    bottom: 100%;
    left: 0;
    background-color: #ffffff;
    border: 1px solid #ddd;  
    border-radius: 8px;      
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);  
    display: flex;
    flex-direction: column;
    width: auto;
    min-width: 120px;        
    margin-bottom: 10px;
}
.tool-options button {
    padding: 10px 15px;      
    border: none;
    background: none;
    text-align: left;
    cursor: pointer;
    white-space: nowrap;
    transition: background-color 0.3s ease;  
    font-size: 1em;          
    font-weight: 500;         
    color: #333;
    border-radius: 4px;
}
.tool-options button:hover {
    background-color: #e0e0e0;  
    color: #000;              
}
details {
    margin-top: 10px;
    border-radius: 4px;
    padding: 5px;
}
summary {
    cursor: pointer;
    font-weight: bold;
}
.ref-content {
    margin-top: 10px;
    justify-content: center;
}
.ref-item {
    margin-bottom: 0px;
}
.ref-item small {
    color: #666;
}
hr {
    margin: 10px 0;
    border: none;
    border-top: 1px solid #eee;
}
.ref-link {
    text-decoration: none;
    color: inherit;
    display: block;
    padding: 5px;
    border-radius: 4px;
    transition: background-color 0.2s;
}
.ref-link:hover {
    background-color: #e3e3ea;
    color: inherit;
}
.ref-link:visited {
    color: inherit;
}
img, video {
    max-width: 100%;
    height: auto;
}
.download-buttons {
    display: flex;
    gap: 5px;
    margin-top: 5px;
}
.download-button {
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    border-radius: 3px;
    padding: 2px 5px;
    font-size: 0.8em;
    cursor: pointer;
    transition: background-color 0.3s;
}
.download-button:hover {
    background-color: #e0e0e0;
}
@media (max-width: 600px) {
    body {
        font-size: 14px;
    }
    #app {
        padding: 0;
    }
    .chat-wrapper {
        height: 100vh;
    }
    .chat-container {
        height: 100vh;
        border-radius: 0;
        margin: 0;
    }
    .sidebar {
        width: 100%;
    }
    .messages {
        padding: 10px;
    }
    .message {
        max-width: 90%;
    }
    #user-input {
        font-size: 16px;
        padding: 12px;
    }
    .send-button, .reset-button {
        width: 44px;
        height: 44px;
    }
    .tool-options {
        width: 100%;
        left: 0;
        right: 0;
    }
    .tool-options button {
        padding: 12px 15px;
    }
}
@media (max-width: 900px) and (orientation: landscape) {
    .chat-container {
        height: 100vh;
    }
    .messages {
        max-height: calc(100vh - 60px);
    }
}
@media (hover: none) {
    .option-button:active {
        background-color: var(--primary-color);
        color: #ffffff;
    }
}
/* Human-in-the-Loop Questions Modal */
.questions-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    animation: fadeIn 0.3s ease;
}
.questions-modal {
    background-color: #ffffff;
    border-radius: 12px;
    padding: 30px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    animation: slideUp 0.3s ease;
}
@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
.questions-modal h2 {
    margin: 0 0 20px 0;
    color: var(--primary-color);
    font-size: 1.5em;
}
.question-item {
    margin-bottom: 25px;
    padding-bottom: 20px;
    border-bottom: 1px solid #e0e0e0;
}
.question-item:last-child {
    border-bottom: none;
}
.question-text {
    font-weight: 500;
    margin-bottom: 12px;
    color: var(--text-color);
    font-size: 1.1em;
}
.question-options {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.option-checkbox {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    background-color: #ffffff;
}
.option-checkbox:hover {
    border-color: var(--primary-color);
    background-color: var(--secondary-color);
}
.option-checkbox.selected {
    border-color: var(--primary-color);
    background-color: var(--primary-color);
    color: #ffffff;
}
.option-checkbox input[type="checkbox"] {
    margin-right: 10px;
    width: 18px;
    height: 18px;
    cursor: pointer;
}
.option-checkbox label {
    flex: 1;
    cursor: pointer;
    user-select: none;
}
.questions-modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 25px;
    padding-top: 20px;
    border-top: 1px solid #e0e0e0;
}
.modal-button {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 1em;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
}
.modal-button-cancel {
    background-color: #f0f0f0;
    color: var(--text-color);
}
.modal-button-cancel:hover {
    background-color: #e0e0e0;
}
.modal-button-submit {
    background-color: var(--primary-color);
    color: #ffffff;
}
.modal-button-submit:hover {
    background-color: #005fa3;
    transform: translateY(-2px);
}
.modal-button-submit:disabled {
    background-color: #ccc;
    cursor: not-allowed;
    transform: none;
}
    </style>
</head>
<body>
    <div id="app">
        <!-- Questions Modal -->
        <div v-if="showQuestionsModal" class="questions-modal-overlay" @click.self="closeQuestionsModal">
            <div class="questions-modal">
                <h2>ðŸ¤” Please Answer These Questions</h2>
                <div v-for="(question, qIndex) in pendingQuestions" :key="question.question_id" class="question-item">
                    <div class="question-text">{{ qIndex + 1 }}. {{ question.question }}</div>
                    <div class="question-options">
                        <div v-for="(option, oIndex) in question.options" 
                             :key="oIndex"
                             class="option-checkbox"
                             :class="{ 'selected': isOptionSelected(question.question_id, option) }"
                             @click="toggleQuestionOption(question.question_id, option)">
                            <input type="checkbox" 
                                   :id="`q_${question.question_id}_${oIndex}`"
                                   :checked="isOptionSelected(question.question_id, option)"
                                   @change="toggleQuestionOption(question.question_id, option)">
                            <label :for="`q_${question.question_id}_${oIndex}`">{{ option }}</label>
                        </div>
                    </div>
                </div>
                <div class="questions-modal-actions">
                    <button class="modal-button modal-button-cancel" @click="closeQuestionsModal">
                        Cancel
                    </button>
                    <button class="modal-button modal-button-submit" 
                            @click="submitAnswers"
                            :disabled="!hasAnyAnswers">
                        Submit Answers
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Chat Container -->
        <div class="chat-wrapper">
            <!-- Sidebar -->
            <div class="sidebar" :class="{ 'sidebar-visible': sidebarVisible }">
                <div class="sidebar-header">
                    <h2>FMCG Agent</h2>
                    <button class="sidebar-close" @click="toggleSidebar">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <button class="new-chat-button" @click="startNewChat">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                    New Chat
                </button>
                <div class="threads-list" v-if="!loadingThreads">
                    <div v-if="threads.length === 0" class="empty-threads">
                        No conversations yet
                    </div>
                    <div v-else>
                        <div v-for="thread in threads" 
                             :key="thread.id" 
                             class="thread-item"
                             :class="{ 'thread-active': thread.id === activeThreadId }"
                             @click="switchToThread(thread.id)">
                            <div class="thread-title">{{ thread.title || 'Untitled' }}</div>
                        </div>
                    </div>
                </div>
                <div v-else class="threads-loading">
                    Loading...
                </div>
            </div>
            <!-- Sidebar Overlay (mobile) -->
            <div class="sidebar-overlay" 
                 v-if="sidebarVisible" 
                 @click="toggleSidebar"></div>
            <!-- Main Chat Container -->
            <div class="chat-container">
                <div class="chat-header">
                    <button class="menu-button" @click="toggleSidebar">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="3" y1="12" x2="21" y2="12"></line>
                            <line x1="3" y1="6" x2="21" y2="6"></line>
                            <line x1="3" y1="18" x2="21" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div class="messages" ref="messageContainer" @scroll="handleScroll">
                <div v-for="(message, index) in messages" :key="index" 
                     :class="['message', message.type === 'user' ? 'user-message' : 'bot-message']">
                    <div v-if="message.type === 'bot' && message.content === ''" id="typing-animation"></div>
                    <div v-else v-html="message.content"></div>
                    <button v-if="message.type === 'bot' && message.audio" @click="toggleAudio(index)" class="audio-button">
                        <svg v-if="!message.isPlaying" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        <svg v-else xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                    </button>
                    <button v-if="message.type === 'bot' && message.rawResponse" @click="copyMarkdownToClipboard(message.rawResponse)" class="copy-button">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                            <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="input-area" :class="{ 'input-hidden': isScrollingUp }">
                <input type="text" id="user-input" v-model="userInput" @keyup.enter="sendMessage" placeholder="Type your message...">
                <button class="send-button" @click="sendMessage">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                </button>
                <button class="reset-button" @click="resetConversation">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                        <path d="M3 3v5h5"></path>
                    </svg>
                </button>
            </div>
        </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        marked.setOptions({
            highlight: function (code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    return hljs.highlight(code, { language: lang }).value;
                } else {
                    return hljs.highlightAuto(code).value;
                }
            },
            sanitize: false
        });
        
        function createTypingAnimation() {
          const container = document.getElementById('typing-animation');
          for (let i = 0; i < 3; i++) {
            const dot = document.createElement('div');
            dot.className = 'dot';
            container.appendChild(dot);
          }
        }

        function extractCustomFileName(html) {
              // Try to find the first h1-h4 tag content
              const headingMatch = html.match(/<h[1-4][^>]*>(.*?)<\/h[1-4]>/i);
              if (headingMatch) {
                  return headingMatch[1].trim();
              }
          
              // If no heading found, use the first 7 words
              const textContent = html.replace(/<[^>]+>/g, ' ').trim();
              const words = textContent.split(/\s+/);
              return words.slice(0, 7).join(' ');
          } 
      
        async function convertHtmlToFile(html, fileType, customFileName = '') {
          
          const url = 'https://pvanand-web-scraping.hf.space/html_to_' + fileType;
          customFileName = extractCustomFileName(html);
          
          function sanitizeFileName(name) {
            return (name.replace(/[^a-z0-9\s]/gi, '')
                       .toLowerCase()
                       .replace(/\s+/g, '_')
                       .substring(0, 50)) || 'generated_report';
          }
          const fileName = `${sanitizeFileName(customFileName || 'generated_report')}.${fileType}`;
          try {
            const response = await fetch(url, {
              method: 'POST',
              headers: { 
                'accept': 'application/json',
                'Content-Type': 'application/json' 
              },
              body: JSON.stringify({ html_content: html })
            });
            if (!response.ok) throw new Error('Conversion failed');
            const blob = await response.blob();
            const a = document.createElement('a');
            a.href = window.URL.createObjectURL(blob);
            a.download = fileName;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(a.href);
          } catch (error) {
            throw new Error(`Failed to download ${fileName}. Please try again.`);
          }
        }

        const app = new Vue({
            el: '#app',
            data: {
                messages: [],
                userInput: '',
                selectedOptions: {},
                conversationId: '',
                threadId: null,
                currentAudio: null,
                isScrollingUp: false,
                lastScrollTop: 0,
                chatStarted: true,
                threads: [],
                loadingThreads: false,
                sidebarVisible: window.innerWidth > 900,
                activeThreadId: null,
                userId: 'string',
                // Human-in-the-loop
                showQuestionsModal: false,
                pendingQuestions: [],
                questionAnswers: {},
                waitingForAnswers: false,
            },
            computed: {
                hasAnyAnswers() {
                    return Object.keys(this.questionAnswers).length > 0 &&
                           Object.values(this.questionAnswers).some(answers => answers.length > 0);
                }
            },
            methods: {
                async loadThreads() {
                    this.loadingThreads = true;
                    try {
                        const response = await fetch(`http://localhost:8000/api/v1/threads?user_id=${this.userId}&limit=20&order=desc`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        this.threads = data.threads || [];
                    } catch (error) {
                        console.error('Error loading threads:', error);
                        this.threads = [];
                    } finally {
                        this.loadingThreads = false;
                    }
                },
                async loadThreadMessages(threadId) {
                    try {
                        const response = await fetch(`http://localhost:8000/api/v1/threads/${threadId}/messages?user_id=${this.userId}&limit=50&order=asc`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        return data.messages || [];
                    } catch (error) {
                        console.error('Error loading messages:', error);
                        throw error;
                    }
                },
                async switchToThread(threadId) {
                    if (this.threadId === threadId) {
                        // Already viewing this thread, just close sidebar on mobile
                        if (window.innerWidth <= 900) {
                            this.sidebarVisible = false;
                        }
                        return;
                    }
                    
                    try {
                        // Load messages for the thread
                        const messages = await this.loadThreadMessages(threadId);
                        
                        // Clear current messages
                        this.messages = [];
                        
                        // Convert API messages to Vue message format
                        messages.forEach(msg => {
                            const messageType = msg.role === 'user' ? 'user' : 'bot';
                            this.messages.push({
                                type: messageType,
                                content: messageType === 'user' 
                                    ? marked.parse(msg.content) 
                                    : marked.parse(msg.content),
                                rawResponse: messageType === 'bot' ? msg.content : null,
                                audio: null,
                                isPlaying: false
                            });
                        });
                        
                        // Set active thread
                        this.threadId = threadId;
                        this.activeThreadId = threadId;
                        this.chatStarted = true;
                        
                        // Close sidebar on mobile
                        if (window.innerWidth <= 900) {
                            this.sidebarVisible = false;
                        }
                        
                        // Scroll to bottom
                        this.$nextTick(() => {
                            this.scrollToBottom();
                        });
                        
                        // Refresh threads list to update ordering
                        await this.loadThreads();
                    } catch (error) {
                        console.error('Error switching thread:', error);
                        alert('Failed to load conversation. Please try again.');
                    }
                },
                startNewChat() {
                    this.threadId = null;
                    this.activeThreadId = null;
                    this.messages = [];
                    this.selectedOptions = {};
                    this.userInput = '';
                    this.isScrollingUp = false;
                    this.lastScrollTop = 0;
                    
                    // Close sidebar on mobile
                    if (window.innerWidth <= 900) {
                        this.sidebarVisible = false;
                    }
                    
                    // Refresh threads list
                    this.loadThreads();
                },
                toggleSidebar() {
                    this.sidebarVisible = !this.sidebarVisible;
                },
                async sendMessage() {
                    console.log('ðŸ“¨ [SEND] Send message called');
                    console.log('   Input:', this.userInput);
                    
                    if (!this.userInput.trim()) {
                        console.log('âš ï¸  [SEND] Empty input, aborting');
                        return;
                    }
                    
                    this.messages.push({ type: 'user', content: marked.parse(this.userInput) });
                    const message = this.userInput;
                    this.userInput = '';
                    this.selectedOptions = {};
                    let streamingIndex = this.messages.push({ type: 'bot', content: '' }) - 1;
                    
                    this.$nextTick(() => {
                        createTypingAnimation();
                    });
                    try {
                        // Initialize thread_id if not set (generate new UUID for new conversation)
                        if (!this.threadId) {
                            this.threadId = uuid.v4();
                            this.activeThreadId = this.threadId;
                            console.log('ðŸ†• [SEND] New thread created:', this.threadId);
                        } else {
                            console.log('ðŸ§µ [SEND] Using existing thread:', this.threadId);
                        }
                        
                        console.log('ðŸ“¡ [SEND] Sending request to backend');
                        console.log('   Message:', message);
                        console.log('   User ID:', this.userId);
                        
                        const response = await fetch('http://localhost:8000/api/v1/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                query: message,
                                thread_id: this.threadId,
                                user_id: this.userId,
                                model_id: 'openai/gpt-4o-mini'
                            })
                        });
                        
                        console.log('ðŸ“¥ [SEND] Response received:', response.status, response.statusText);
                        
                        if (!response.ok) {
                            console.error('âŒ [SEND] HTTP error:', response.status);
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        console.log('ðŸ”„ [SEND] Starting to stream response');
                        
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let rawResponse = '';
                        let toolEvents = [];
                        let buffer = '';
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) {
                                console.log('ðŸ [STREAM] Stream completed');
                                break;
                            }
                            
                            const decodedValue = decoder.decode(value, { stream: true });
                            console.log('ðŸ“¦ [RAW CHUNK]', decodedValue);
                            
                            buffer += decodedValue;
                            const lines = buffer.split('\n');
                            buffer = lines.pop() || ''; // Keep incomplete line in buffer
                            
                            console.log(`ðŸ“ [BUFFER] Processing ${lines.length} line(s)`);
                            
                            for (const line of lines) {
                                if (!line.trim()) {
                                    console.log('â­ï¸  [SKIP] Empty line');
                                    continue;
                                }
                                
                                // Handle SSE format (strip "data: " prefix if present)
                                let jsonLine = line.trim();
                                console.log('ðŸ“„ [LINE]', jsonLine);
                                
                                if (jsonLine.startsWith('data: ')) {
                                    jsonLine = jsonLine.substring(6);
                                    console.log('ðŸ”„ [SSE] Stripped "data:" prefix:', jsonLine);
                                }
                                
                                try {
                                    const chunk = JSON.parse(jsonLine);
                                    console.log('âœ… [PARSED]', chunk);
                                    console.log(`ðŸ” [TYPE] Chunk type: "${chunk.type}"`);
                                    
                                    if (chunk.type === 'chunk' && chunk.content) {
                                        console.log('ðŸ’¬ [CHUNK] Content chunk:', chunk.content.substring(0, 50) + '...');
                                        rawResponse += chunk.content;
                                        this.$set(this.messages[streamingIndex], 'content', marked.parse(rawResponse));
                                    }
                                    else if (chunk.type === 'questions_pending') {
                                        // Human-in-the-loop: Agent is asking questions
                                        console.log('ðŸ¤” [HITL] Questions pending detected!');
                                        console.log('ðŸ“‹ [HITL] Questions:', chunk.questions);
                                        console.log(`ðŸ”¢ [HITL] Number of questions: ${chunk.questions.length}`);
                                        console.log('ðŸ§µ [HITL] Thread ID:', chunk.thread_id);
                                        
                                        // Remove the typing animation message
                                        if (this.messages[streamingIndex].content === '') {
                                            console.log('ðŸ—‘ï¸  [HITL] Removing empty typing message');
                                            this.messages.splice(streamingIndex, 1);
                                        }
                                        // Show questions modal
                                        console.log('ðŸŽ¬ [HITL] Showing question dialog...');
                                        this.showQuestionDialog(chunk.questions);
                                        console.log('â¸ï¸  [HITL] Exiting stream, waiting for user answers');
                                        return; // Exit stream, wait for user answers
                                    }
                                    else if (chunk.type === 'tool_start') {
                                        console.log('ðŸ”§ [TOOL START]', chunk.name, chunk.input);
                                        toolEvents.push({
                                            type: 'tool_start',
                                            name: chunk.name,
                                            input: chunk.input
                                        });
                                    }
                                    else if (chunk.type === 'tool_end') {
                                        console.log('âœ… [TOOL END]', chunk.name);
                                        toolEvents.push({
                                            type: 'tool_end',
                                            name: chunk.name,
                                            output: chunk.output
                                        });
                                    }
                                    else if (chunk.type === 'full_response' && chunk.content) {
                                        console.log('ðŸ [FULL RESPONSE] Received');
                                        console.log('ðŸ“Š [USAGE]', chunk.usage_metadata);
                                        rawResponse = chunk.content;
                                        this.$set(this.messages[streamingIndex], 'content', marked.parse(rawResponse));
                                        this.$set(this.messages[streamingIndex], 'rawResponse', rawResponse);
                                        
                                        // Display tool events if any
                                        if (toolEvents.length > 0) {
                                            console.log(`ðŸ”§ [TOOLS] ${toolEvents.length} tool event(s) to display`);
                                            let toolsMessage = "\n\n**Tools Used:**\n";
                                            toolEvents.forEach(event => {
                                                if (event.type === 'tool_start') {
                                                    const inputStr = typeof event.input === 'object' 
                                                        ? JSON.stringify(event.input) 
                                                        : event.input;
                                                    toolsMessage += `- ${event.name.charAt(0).toUpperCase() + event.name.slice(1)}: ${inputStr}\n`;
                                                }
                                            });
                                            this.$set(this.messages[streamingIndex], 'content', 
                                                this.messages[streamingIndex].content + marked.parse(toolsMessage));
                                        }
                                    }
                                    else if (chunk.type === 'error') {
                                        console.error('âŒ [ERROR] Error chunk received:', chunk.content);
                                        throw new Error(chunk.content || 'An error occurred');
                                    }
                                    else {
                                        console.warn('âš ï¸  [UNKNOWN] Unknown chunk type:', chunk.type);
                                    }
                                } catch (parseError) {
                                    // Skip invalid JSON lines
                                    console.warn('âš ï¸  [PARSE ERROR] Failed to parse chunk:', line);
                                    console.warn('   Error:', parseError);
                                }
                            }
                        }
                        
                        // Process any remaining buffer
                        if (buffer.trim()) {
                            console.log('ðŸ“¦ [SEND] Processing remaining buffer:', buffer);
                            try {
                                const chunk = JSON.parse(buffer);
                                console.log('âœ… [SEND] Buffer parsed:', chunk);
                                if (chunk.type === 'full_response' && chunk.content) {
                                    rawResponse = chunk.content;
                                    this.$set(this.messages[streamingIndex], 'content', marked.parse(rawResponse));
                                    this.$set(this.messages[streamingIndex], 'rawResponse', rawResponse);
                                }
                            } catch (e) {
                                console.warn('âš ï¸  [SEND] Failed to parse buffer:', e);
                            }
                        }
                        
                        // Ensure rawResponse is set
                        if (!this.messages[streamingIndex].rawResponse) {
                            console.log('ðŸ“ [SEND] Setting rawResponse');
                            this.$set(this.messages[streamingIndex], 'rawResponse', rawResponse);
                        }
                        
                        // Generate audio from cleaned text
                        console.log('ðŸ”Š [SEND] Generating audio...');
                        const cleanText = rawResponse.replace(/[#!*_\[\]\(\)`]/g, '');
                        const audioUrl = await this.convertToSpeech(cleanText);
                        if (audioUrl) {
                            console.log('âœ… [SEND] Audio generated');
                            this.$set(this.messages[streamingIndex], 'audio', audioUrl);
                        } else {
                            console.log('âš ï¸  [SEND] Audio generation skipped');
                        }
                        
                        // Refresh threads list after message is sent
                        console.log('ðŸ”„ [SEND] Refreshing threads list');
                        await this.loadThreads();
                        console.log('âœ… [SEND] Complete!');
                    } catch (error) {
                        console.error('âŒ [SEND] Error:', error);
                        console.error('   Stack:', error.stack);
                        this.messages.push({ type: 'bot', content: 'An error occurred while processing your request: ' + error.message });
                    }
                    this.$nextTick(() => this.scrollToBottom());
                },
                handleScroll(event) {
                    const st = event.target.scrollTop;
                    this.isScrollingUp = st < this.lastScrollTop;
                    this.lastScrollTop = st <= 0 ? 0 : st;
                },
                renderClarificationQuestions(clarification, messageIndex) {
                    if (!clarification || clarification.length === 0) return;
    
                    let clarificationHtml = '';
                    clarification.forEach((item, questionIndex) => {
                        clarificationHtml += `<strong>${item.question}</strong><br>`;
                        clarificationHtml += '<div class="option-buttons">';
                        item.options.forEach((option, optionIndex) => {
                            const escapedOption = option.replace(/'/g, "\\'");
                            clarificationHtml += `<button class="option-button" onclick="app.toggleOption('${escapedOption}', ${questionIndex}, ${optionIndex})">${option}</button>`;
                        });
                        clarificationHtml += '</div><br>';
                    });
    
                    this.$set(this.messages[messageIndex], 'content', this.messages[messageIndex].content + marked.parse(clarificationHtml));
                    this.$nextTick(() => {
                        this.scrollToBottom();
                        this.updateButtonStates();
                    });
                },
                toggleOption(option, questionIndex, optionIndex) {
                    if (!this.selectedOptions[questionIndex]) {
                        this.$set(this.selectedOptions, questionIndex, []);
                    }
        
                    const index = this.selectedOptions[questionIndex].indexOf(option);
                    if (index > -1) {
                        this.selectedOptions[questionIndex].splice(index, 1);
                    } else {
                        this.selectedOptions[questionIndex].push(option);
                    }
        
                    this.updateInputFromSelectedOptions();
                    this.updateButtonStates();
                },
                updateInputFromSelectedOptions() {
                    this.userInput = Object.entries(this.selectedOptions)
                        .map(([questionIndex, options]) => 
                            `Q${parseInt(questionIndex) + 1}: ${options.join(', ')}`)
                        .join(' | ');
                    this.$nextTick(() => document.getElementById('user-input').focus());
                },
                updateButtonStates() {
                    Object.entries(this.selectedOptions).forEach(([questionIndex, options]) => {
                        const buttons = document.querySelectorAll(`.option-buttons:nth-of-type(${parseInt(questionIndex) + 1}) .option-button`);
                        buttons.forEach((button) => {
                            if (options.includes(button.textContent)) {
                                button.classList.add('selected');
                            } else {
                                button.classList.remove('selected');
                            }
                        });
                    });
                },
                resetConversation() {
                    this.startNewChat();
                },
                scrollToBottom() {
                    const container = this.$refs.messageContainer;
                    container.scrollTop = container.scrollHeight;
                },
                async convertToSpeech(text) {
                    const voice = 'en-US-JennyNeural';
                    const encodedText = encodeURIComponent(text);
                    try {
                        const response = await fetch(`https://pvanand-audio-chat-indic.hf.space/auto-tts?text=${encodedText}`, {
                            method: 'GET',
                            headers: {
                                'accept': 'application/json'
                            }
                        });
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const blob = await response.blob();
                        return URL.createObjectURL(blob);
                    } catch (error) {
                        console.error('Error:', error);
                        return null;
                    }
                },
                toggleAudio(index) {
                    const message = this.messages[index];
                    if (this.currentAudio && this.currentAudio !== message.audioElement) {
                        this.currentAudio.pause();
                        this.messages.forEach(m => {
                            if (m.audioElement === this.currentAudio) {
                                m.isPlaying = false;
                            }
                        });
                    }
                    if (!message.audioElement) {
                        message.audioElement = new Audio(message.audio);
                        message.audioElement.addEventListener('ended', () => {
                            message.isPlaying = false;
                            this.$forceUpdate();
                        });
                    }
                    if (message.isPlaying) {
                        message.audioElement.pause();
                    } else {
                        message.audioElement.play();
                        this.currentAudio = message.audioElement;
                    }
                    message.isPlaying = !message.isPlaying;
                    this.$forceUpdate();
                },
                copyMarkdownToClipboard(rawResponse) {
                    navigator.clipboard.writeText(rawResponse).then(() => {
                        // remove alert
                    }).catch(err => {
                        console.error('Failed to copy: ', err);
                    });
                },
                async downloadResponse(rawResponse, fileType) {
                    try {
                        const html = marked.parse(rawResponse);
                        await convertHtmlToFile(html, fileType);
                    } catch (error) {
                        console.error('Error downloading file:', error);
                        // You might want to show an error message to the user here
                    }
                },
                // Human-in-the-Loop Methods
                showQuestionDialog(questions) {
                    this.pendingQuestions = questions;
                    this.questionAnswers = {};
                    this.showQuestionsModal = true;
                    this.waitingForAnswers = true;
                },
                toggleQuestionOption(questionId, option) {
                    if (!this.questionAnswers[questionId]) {
                        this.$set(this.questionAnswers, questionId, []);
                    }
                    
                    const index = this.questionAnswers[questionId].indexOf(option);
                    if (index > -1) {
                        this.questionAnswers[questionId].splice(index, 1);
                    } else {
                        this.questionAnswers[questionId].push(option);
                    }
                },
                isOptionSelected(questionId, option) {
                    return this.questionAnswers[questionId] && 
                           this.questionAnswers[questionId].includes(option);
                },
                closeQuestionsModal() {
                    this.showQuestionsModal = false;
                    this.pendingQuestions = [];
                    this.questionAnswers = {};
                    this.waitingForAnswers = false;
                },
                async submitAnswers() {
                    console.log('ðŸ“¤ [SUBMIT] Submit answers clicked');
                    console.log('   Answers:', JSON.stringify(this.questionAnswers, null, 2));
                    
                    if (!this.hasAnyAnswers) {
                        console.warn('âš ï¸  [SUBMIT] No answers selected');
                        alert('Please select at least one option before submitting.');
                        return;
                    }
                    
                    console.log('âœ… [SUBMIT] Valid answers, proceeding');
                    
                    // Close the modal
                    this.showQuestionsModal = false;
                    
                    // Add a user message showing selected answers
                    let answerSummary = "**My Answers:**\n\n";
                    this.pendingQuestions.forEach(q => {
                        const answers = this.questionAnswers[q.question_id] || [];
                        answerSummary += `- **${q.question}**: ${answers.join(', ') || '(no selection)'}\n`;
                    });
                    this.messages.push({ type: 'user', content: marked.parse(answerSummary) });
                    
                    // Add streaming bot message
                    let streamingIndex = this.messages.push({ type: 'bot', content: '' }) - 1;
                    
                    this.$nextTick(() => {
                        createTypingAnimation();
                    });
                    
                    try {
                        console.log('ðŸ“¡ [RESUME] Sending resume request to backend');
                        console.log('   Thread ID:', this.threadId);
                        console.log('   User ID:', this.userId);
                        
                        // Send resume request with answers
                        const response = await fetch('http://localhost:8000/api/v1/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                thread_id: this.threadId,
                                user_id: this.userId,
                                model_id: 'openai/gpt-4o-mini',
                                resume_data: {
                                    answers: this.questionAnswers
                                }
                            })
                        });
                        
                        console.log('ðŸ“¥ [RESUME] Response received:', response.status, response.statusText);
                        
                        if (!response.ok) {
                            console.error('âŒ [RESUME] HTTP error:', response.status);
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        console.log('ðŸ”„ [RESUME] Starting to stream response');
                        
                        // Stream the response
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let rawResponse = '';
                        let toolEvents = [];
                        let buffer = '';
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) {
                                console.log('ðŸ [RESUME STREAM] Stream completed');
                                break;
                            }
                            
                            const decodedValue = decoder.decode(value, { stream: true });
                            console.log('ðŸ“¦ [RESUME RAW]', decodedValue);
                            
                            buffer += decodedValue;
                            const lines = buffer.split('\n');
                            buffer = lines.pop() || '';
                            
                            console.log(`ðŸ“ [RESUME BUFFER] Processing ${lines.length} line(s)`);
                            
                            for (const line of lines) {
                                if (!line.trim()) {
                                    console.log('â­ï¸  [RESUME] Empty line');
                                    continue;
                                }
                                
                                let jsonLine = line.trim();
                                console.log('ðŸ“„ [RESUME LINE]', jsonLine);
                                
                                if (jsonLine.startsWith('data: ')) {
                                    jsonLine = jsonLine.substring(6);
                                    console.log('ðŸ”„ [RESUME SSE] Stripped prefix:', jsonLine);
                                }
                                
                                try {
                                    const chunk = JSON.parse(jsonLine);
                                    console.log('âœ… [RESUME PARSED]', chunk);
                                    console.log(`ðŸ” [RESUME TYPE] "${chunk.type}"`);
                                    
                                    if (chunk.type === 'chunk' && chunk.content) {
                                        console.log('ðŸ’¬ [RESUME CHUNK]', chunk.content.substring(0, 50) + '...');
                                        rawResponse += chunk.content;
                                        this.$set(this.messages[streamingIndex], 'content', marked.parse(rawResponse));
                                    }
                                    else if (chunk.type === 'questions_pending') {
                                        // Handle additional questions (recursive)
                                        console.log('ðŸ¤” [RESUME HITL] Additional questions detected!');
                                        console.log('ðŸ“‹ [RESUME HITL] Questions:', chunk.questions);
                                        console.log('ðŸ”„ [RESUME HITL] Recursive HITL - showing new questions');
                                        this.showQuestionDialog(chunk.questions);
                                        console.log('â¸ï¸  [RESUME HITL] Exiting resume stream');
                                        return; // Exit this stream, wait for new answers
                                    }
                                    else if (chunk.type === 'tool_start') {
                                        console.log('ðŸ”§ [RESUME TOOL START]', chunk.name, chunk.input);
                                        toolEvents.push({
                                            type: 'tool_start',
                                            name: chunk.name,
                                            input: chunk.input
                                        });
                                    }
                                    else if (chunk.type === 'tool_end') {
                                        console.log('âœ… [RESUME TOOL END]', chunk.name);
                                        toolEvents.push({
                                            type: 'tool_end',
                                            name: chunk.name,
                                            output: chunk.output
                                        });
                                    }
                                    else if (chunk.type === 'full_response' && chunk.content) {
                                        console.log('ðŸ [RESUME FULL RESPONSE] Received');
                                        console.log('ðŸ“Š [RESUME USAGE]', chunk.usage_metadata);
                                        rawResponse = chunk.content;
                                        this.$set(this.messages[streamingIndex], 'content', marked.parse(rawResponse));
                                        this.$set(this.messages[streamingIndex], 'rawResponse', rawResponse);
                                        
                                        if (toolEvents.length > 0) {
                                            console.log(`ðŸ”§ [RESUME TOOLS] ${toolEvents.length} tool event(s)`);
                                            let toolsMessage = "\n\n**Tools Used:**\n";
                                            toolEvents.forEach(event => {
                                                if (event.type === 'tool_start') {
                                                    const inputStr = typeof event.input === 'object' 
                                                        ? JSON.stringify(event.input) 
                                                        : event.input;
                                                    toolsMessage += `- ${event.name.charAt(0).toUpperCase() + event.name.slice(1)}: ${inputStr}\n`;
                                                }
                                            });
                                            this.$set(this.messages[streamingIndex], 'content', 
                                                this.messages[streamingIndex].content + marked.parse(toolsMessage));
                                        }
                                    }
                                    else if (chunk.type === 'error') {
                                        console.error('âŒ [RESUME ERROR]', chunk.content);
                                        throw new Error(chunk.content || 'An error occurred');
                                    }
                                    else {
                                        console.warn('âš ï¸  [RESUME UNKNOWN]', chunk.type);
                                    }
                                } catch (parseError) {
                                    console.warn('âš ï¸  [RESUME PARSE ERROR]', line);
                                    console.warn('   Error:', parseError);
                                }
                            }
                        }
                        
                        // Clean up
                        console.log('ðŸ§¹ [RESUME] Cleaning up');
                        this.waitingForAnswers = false;
                        this.questionAnswers = {};
                        this.pendingQuestions = [];
                        console.log('âœ… [RESUME] Cleanup complete');
                        
                        // Ensure rawResponse is set
                        if (!this.messages[streamingIndex].rawResponse) {
                            console.log('ðŸ“ [RESUME] Setting rawResponse');
                            this.$set(this.messages[streamingIndex], 'rawResponse', rawResponse);
                        }
                        
                        // Generate audio
                        console.log('ðŸ”Š [RESUME] Generating audio...');
                        const cleanText = rawResponse.replace(/[#!*_\[\]\(\)`]/g, '');
                        const audioUrl = await this.convertToSpeech(cleanText);
                        if (audioUrl) {
                            console.log('âœ… [RESUME] Audio generated');
                            this.$set(this.messages[streamingIndex], 'audio', audioUrl);
                        } else {
                            console.log('âš ï¸  [RESUME] Audio generation skipped');
                        }
                        
                        // Refresh threads
                        console.log('ðŸ”„ [RESUME] Refreshing threads list');
                        await this.loadThreads();
                        console.log('âœ… [RESUME] Complete!');
                    } catch (error) {
                        console.error('âŒ [RESUME] Error submitting answers:', error);
                        console.error('   Stack:', error.stack);
                        this.messages.push({ type: 'bot', content: 'An error occurred while processing your answers: ' + error.message });
                        this.waitingForAnswers = false;
                    }
                    
                    this.$nextTick(() => this.scrollToBottom());
                },
            },
            watch: {
                userInput(newVal, oldVal) {
                    // Watch for user input changes if needed
                }
            },
            mounted() {
                this.resetConversation();
                // Load threads on mount
                this.loadThreads();
            }
        });
    </script>
</body>
</html>
